package I_encapsulationAndStatic;

/**
 * Инкапсуляция.
 * Инкапсуляция с использованием статики.
 * Это пример работы статического метода.
 * Теоретически к статическому методу есть доступ через экземпляр, но в этом нет особого смысла,
 * так как он принадлежит классу, и возможность переопределения этого метода не доступна.
 * Поэтому рекомендуется обращаться к методу через название класса, а не через созданный экземпляр.
 * Во-первых, не нужно создавать лишний объект.
 * Во-вторых, Сразу видно, что работаем со статикой.
 * В-третьих, нужно помнить, что статика инициализируется сразу, при запуске проекта.
 * В противовес напомню, что не статические методы и поля класса,
 * инициализируются в момент создания экземпляра того класса в котором находятся.
 * Другими словами уровень "Видимости" статики в проекте выше.
 * А если в данном примере закрыть с помощью privet переменную счёта cashAccount,
 * убрать сеттеры и геттеры к этой переменной,
 * закрыть с помощью privet метод соединения с банком и списания средств,
 * сделать этот метод статическим, то мы добиваемся инкапсуляции части кода, которую менять нельзя,
 * и доступ к которой должен быть закрытым.
 * <p>
 * Инкапсуляция с помощью модификатора final.
 * Данный модификатор запрещает переопределение метода, если он указан в методе при его объявлении.
 * <p>
 * Пример, как работает статика.
 * Два метода, один экземпляр ,второй статика.
 * Статичный совершает соединение с БД Банка и производит операцию. В нём же установлен лимит снятия и проверка.
 * Мы не можем его переопределить и изменить состояние.
 * А если закрыть privet, то доступ к нему только через второй метод.
 * Так же закрыта переменная отражающая общий счёт.
 * В данном случае сеттеры и геттеры должны отсутствовать.
 */

 final class Money {
    //final class Money { //Данное использование final запрещает наследование от данного класса.
    private static Money money;

    //private  int cashAccount = 100000;
    private static int cashAccount = 100000;
    //private  int MAX_REQUEST;
    private final static int MAX_REQUEST = 100;


    //Создавая singleton, мы запрещаем создание экземпляра.
//     Money(int a) {
//    }
    private Money() {
    }
    //
    public static Money singleton() { //Но даже такое условие можно обойти, создав два и более потока.
        if(money == null) {
            money = new Money();
        }
        return money;
    }


    public final int request(int request) {  //Вызываемый метод, с входным запросом.
        return paymentOfTheMoney(request);
        //return  this.paymentOfTheMoney(request); //такой вид вызова, если метод не статический.
    }

      private static int paymentOfTheMoney(int request) {  //Это правильное закрытие кода через статику.
        //public int paymentOfTheMoney(int request) {
        //private final int paymentOfTheMoney(int request) {    //Это правильное закрытие кода через экземпляр.
        //public static int paymentOfTheMoney(int request) {
        //protected static int paymentOfTheMoney(int request) {
        //MAX_REQUEST = 100;
        if (request <= MAX_REQUEST && cashAccount >= request) {
            cashAccount = cashAccount - request;
            System.out.println("Максимально возможная единоразовая выдача суммы составляет: " + MAX_REQUEST + "р.");
            System.out.println("Сумма к выдаче: " + request + "р.");
            System.out.println("Остаток на счёте: " + cashAccount + "р.");
            System.out.println("Реальное соединение с Банковским счётом."); //это имитация онлайн соединения с Банком
            System.out.println("Подтверждение Банка о списании.");
            return request;
        }
        System.out.println("Превышен лимит запроса!");
        return 0;
    }

    //Геттер нужно отключить, это временный пример для хака.
    //А сеттера тут нет вообще.
//    public int getCashAccount() {
//        return cashAccount;
//    }
}

